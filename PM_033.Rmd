---
title: "PM_033"
author: "Sarah LE COZ"
date: "2024-05-22"
output: pdf_document
---

```{r}
library(tidyverse)
library(shiny)
library(htmlwidgets)
library(lattice)
library(mvtnorm)
library(DoseFinding)
library(readr)
library(stats)
library(modelr)
library(tidyverse)
library(gridExtra)
```

#data_set
```{r}
data_set <- read_csv2(
  "N:/4_PROJETS/2022/EMAD_22TQ_Ratio/StageM2_2024/Analyse_R/data_set.csv",
  col_types = cols(
    Idbis = col_character(),
    TIME = col_number(),
    OBS_CFU = col_number(),
    LOG10_CFU = col_number(),
    delta_LOG10 = col_number(),
    CMI = col_number(),
    xCMI = col_number(),
    OUTLIER = col_number(),
    CONC_sulf = col_number(),
    CONC_TMP = col_number()
  ),
  trim_ws = TRUE
)

data_set$ID<-as.factor(data_set$ID)

#Enlever les OUTLIER==1
data_set %>% filter(OUTLIER==0)->data_set

problems(data_set)
```

#Courbes uniques
```{r}
library(paletteer)

#Graphe de chaque KC
ggplot(data_set, aes(x = TIME, y = LOG10_CFU, group = xCMI, color = factor(xCMI))) +
  geom_line() +
  geom_point(shape = 18) +
  scale_color_paletteer_d("ggthemes::gdoc") +
  facet_wrap(~ ID)
```

#AUC
```{r}
# Fonction pour calculer l'aire sous une courbe en utilisant la methode des trapezes
calculate_area_trapezoids <- function(x, y) {
  # S'assurer que les donnees sont triees par x
  sorted_indices <- order(x)
  x <- x[sorted_indices]
  y <- y[sorted_indices]
  # Calculer l'aire en utilisant la methode des trapezes
  area <- sum(diff(x) * (head(y, -1) + tail(y, -1)) / 2)
  return(area)
}

# Agreger les donnees par ID, xCMI et TIME, en calculant la moyenne de LOG10_CFU pour chaque groupe
grouped_data_2 <- data_set %>%
  group_by(ID, xCMI, TIME, CONC_TMP, Idbis, ratio, MOLECULE) %>%
  summarize(avg_LOG10_CFU = mean(LOG10_CFU, na.rm = TRUE), .groups = 'drop')

# Calculer l'aire sous chaque courbe pour chaque combinaison de ID et xCMI
areas <- grouped_data_2 %>%
  group_by(ID, Idbis, xCMI, CONC_TMP, ratio, MOLECULE) %>%
  summarize(area_under_curve = calculate_area_trapezoids(TIME, avg_LOG10_CFU), .groups = 'drop')

# AUC : histogramme par xCMI
ggplot(areas, aes(x = factor(xCMI), y = area_under_curve, fill = factor(xCMI))) +
  geom_bar(stat = "identity") +
  facet_wrap(~ ID) +
  labs(title = "Aire sous chaque courbe par ID et xCMI", x = "xCMI", y = "Aire sous la courbe") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  scale_fill_discrete(name = "xCMI")
```

#Equation 1 : Croissance moyenne de l'inoculum
```{r}
#inoculum moyen obtenu apres exposition à ATB pendant 24h (ou 8h pour ID 3, 5 et 33)

Ix <- ifelse(areas$ID %in% c(3, 5, 19, 33), areas$area_under_curve/8, areas$area_under_curve/24)

tableau_Ix <- data.frame(ID = areas$ID, Idbis=areas$Idbis, xCMI = areas$xCMI, Ix = Ix)

#taille de l'inoculum de depart
# Filtrer les donnees pour obtenir les valeurs à TIME = 0.00 pour chaque combinaison de xCMI et ID
valeurs_inoculum <- data_set %>%
  filter(TIME == 0.00) %>%
  select(ID, xCMI, LOG10_CFU)

IBasal<-valeurs_inoculum$LOG10_CFU
  
#croissance moyenne de l'incoulum sur 24h
delta_i_x<-Ix-IBasal

tableau_delta_i_x<- data.frame(ID = areas$ID, xCMI = areas$xCMI, Idbis = areas$Idbis, ratio = areas$ratio, MOLECULE =areas$MOLECULE, delta_i_x = delta_i_x)

tableau_delta_i_x <- data.frame(ID = areas$ID,
                                xCMI = areas$xCMI,
                                delta_i_x = delta_i_x,
                                CONC_TMP = areas$CONC_TMP,
                                Idbis = areas$Idbis,
                                ratio = areas$ratio,
                                MOLECULE =areas$MOLECULE)
```

#delta i x par ATB, seul ou combi
```{r}

#ATB seuls
SMX<- tableau_delta_i_x %>%
  filter(MOLECULE == "SMX" & ratio == 0)

SDMX<- tableau_delta_i_x %>%
  filter(MOLECULE == "SDMX" & ratio == 0)

SDZ<- tableau_delta_i_x %>%
  filter(MOLECULE == "SDZ" & ratio == 0)

TMP<- tableau_delta_i_x %>%
  filter(MOLECULE == "TMP" & ratio == 0)


#1_19
SMX_1_19<- tableau_delta_i_x %>%
  filter(MOLECULE == "SMX/TMP" & ratio == "1_19")

SDMX_1_19<- tableau_delta_i_x %>%
  filter(MOLECULE == "SDMX/TMP" & ratio == "1_19")

SDZ_1_19<- tableau_delta_i_x %>%
  filter(MOLECULE == "SDZ/TMP" & ratio == "1_19")

#1_99
SMX_1_99<- tableau_delta_i_x %>%
  filter(MOLECULE == "SMX/TMP" & ratio == "1_99")

SDMX_1_99<- tableau_delta_i_x %>%
  filter(MOLECULE == "SDMX/TMP" & ratio == "1_99")

SDZ_1_99<- tableau_delta_i_x %>%
  filter(MOLECULE == "SDZ/TMP" & ratio == "1_99")

#1_999
SMX_1_999<- tableau_delta_i_x %>%
  filter(MOLECULE == "SMX/TMP" & ratio == "1_999")

SDMX_1_999<- tableau_delta_i_x %>%
  filter(MOLECULE == "SDMX/TMP" & ratio == "1_999")

SDZ_1_999<- tableau_delta_i_x %>%
  filter(MOLECULE == "SDZ/TMP" & ratio == "1_999")
  
```


#Equation 2 : Modele sigmoide Emax, modelisation de la croissance moyenne de l'inoculum
```{r}
start_values <- list(
  delta_i_max = max(tableau_delta_i_x$delta_i_x, na.rm = TRUE),
  delta_i_min = min(tableau_delta_i_x$delta_i_x, na.rm = TRUE),
  EC2LOG = 1.13,
  gam = 2.2
)

library(minpack.lm)

#equation sans ECLOG2
#essai_model_lm <- nlsLM(delta_i_x ~ delta_i_max - ((delta_i_max - delta_i_min) * ((CONC_TMP / EC)^gam) / (((-delta_i_min) / delta_i_max) + (CONC_TMP / EC)^gam)),data = tableau_delta_i_x,start = start_values)


essai_model_lm <- nlsLM(
 delta_i_x ~ delta_i_max - ((delta_i_max - delta_i_min) * ((CONC_TMP / EC2LOG)^gam) / (((-2 - delta_i_min) / delta_i_max + 2) + (CONC_TMP / EC2LOG)^gam)),
  data = tableau_delta_i_x,
  start = start_values,
  control = nls.lm.control(maxiter = 200))


#obtenir les valeurs des parametres
parameters <- summary(essai_model_lm)

print(coef(parameters))

param_table <- data.frame( 
  Parameter = c("delta_i_max", "delta_i_min", "EC2LOG", "gam"), 
  Estimate = c(3.608951e+00, -5.902751e-01, 6.349459e-06, 2.821904e-01), 
  Std_Error = c(0.3470628443, 0.4924019135, 0.0000470201, 0.3483075548), 
  t_value = c(10.3985529, -1.1987668, 0.1350371, 0.8101758), Pr = c(2.160578e-21, 2.317143e-01, 8.926874e-01, 4.185829e-01) ) 

print(param_table)

library(writexl)
write_xlsx(param_table, "param_033.xlsx")

#obtenir la valeur de R²
#(essai_model_lm,tableau_delta_i_x)

library(broom)

# Calculer la valeur de R²
predictions <- predict(essai_model_lm, tableau_delta_i_x)
residuals <- tableau_delta_i_x$delta_i_x - predictions
ss_residuals <- sum(residuals^2)
ss_total <- sum((tableau_delta_i_x$delta_i_x - mean(tableau_delta_i_x$delta_i_x))^2)
r_squared <- 1 - (ss_residuals / ss_total)
cat("R-squared:", r_squared, "\n")

plot_by_MOLECULE_ratio <- ggplot(tableau_delta_i_x, aes(x = CONC_TMP, y = delta_i_x)) +
  geom_point(color = "blue", size = 2) +  # Points des données observées
  geom_line(aes(y = predict(essai_model_lm, newdata = tableau_delta_i_x)), color = "red", size = 1) +  # Ligne du modèle ajusté
  labs(title = "", x = "CONC_TMP", y = "delta_i_x") +
  theme_minimal() +
  facet_wrap(~ MOLECULE + ratio)

print(plot_by_MOLECULE_ratio)

```

# Tracer les données et le modèle ajusté
ggplot(tableau_delta_i_x_clean, aes(x = CONC_TMP, y = delta_i_x)) +
  geom_point(color = "blue", size = 2) +  # Points des données observées
  geom_line(aes(y = predict(essai_model_lm, newdata = tableau_delta_i_x_clean)), color = "red", linewidth = 1) +  # Ligne du modèle ajusté
  labs(title = "", x = "CONC_TMP", y = "delta_i_x") +
  theme_minimal()

#Equation 2 : Modele sigmoide Emax, modelisation de la croissance moyenne de l'inoculum
```{r}
start_values <- list(
  delta_i_max = max(tableau_delta_i_x$delta_i_x, na.rm = TRUE),
  delta_i_min = min(tableau_delta_i_x$delta_i_x, na.rm = TRUE),
  EC2LOG = 1.13,
  gam = 2.2
)

library(minpack.lm)

#ATBs
smx <- nlsLM(
 delta_i_x ~ delta_i_max - ((delta_i_max - delta_i_min) * ((CONC_TMP / EC2LOG)^gam) / (((-2 - delta_i_min) / delta_i_max + 2) + (CONC_TMP / EC2LOG)^gam)),
  data = SMX,
  start = start_values,
  control = nls.lm.control(maxiter = 200))

parameters_smx <- summary(smx)

sdmx <- nlsLM(
 delta_i_x ~ delta_i_max - ((delta_i_max - delta_i_min) * ((CONC_TMP / EC2LOG)^gam) / (((-2 - delta_i_min) / delta_i_max + 2) + (CONC_TMP / EC2LOG)^gam)),
  data = SDMX,
  start = start_values,
  control = nls.lm.control(maxiter = 200))

parameters_sdmx <- summary(sdmx)

sdz <- nlsLM(
 delta_i_x ~ delta_i_max - ((delta_i_max - delta_i_min) * ((CONC_TMP / EC2LOG)^gam) / (((-2 - delta_i_min) / delta_i_max + 2) + (CONC_TMP / EC2LOG)^gam)),
  data = SDZ,
  start = start_values,
  control = nls.lm.control(maxiter = 200))

parameters_sdz <- summary(sdz)

tmp <- nlsLM(
 delta_i_x ~ delta_i_max - ((delta_i_max - delta_i_min) * ((CONC_TMP / EC2LOG)^gam) / (((-2 - delta_i_min) / delta_i_max + 2) + (CONC_TMP / EC2LOG)^gam)),
  data = TMP,
  start = start_values,
  control = nls.lm.control(maxiter = 200))

parameters_tmp <- summary(tmp)

#1_19
smx_1_19 <- nlsLM(
 delta_i_x ~ delta_i_max - ((delta_i_max - delta_i_min) * ((CONC_TMP / EC2LOG)^gam) / (((-2 - delta_i_min) / delta_i_max + 2) + (CONC_TMP / EC2LOG)^gam)),
  data = SMX_1_19,
  start = start_values,
  control = nls.lm.control(maxiter = 200))

parameters_smx_1_19 <- summary(smx_1_19)

sdmx_1_19 <- nlsLM(
 delta_i_x ~ delta_i_max - ((delta_i_max - delta_i_min) * ((CONC_TMP / EC2LOG)^gam) / (((-2 - delta_i_min) / delta_i_max + 2) + (CONC_TMP / EC2LOG)^gam)),
  data = SDMX_1_19,
  start = start_values,
  control = nls.lm.control(maxiter = 200))

parameters_sdmx_1_19 <- summary(sdmx_1_19)

sdz_1_19 <- nlsLM(
 delta_i_x ~ delta_i_max - ((delta_i_max - delta_i_min) * ((CONC_TMP / EC2LOG)^gam) / (((-2 - delta_i_min) / delta_i_max + 2) + (CONC_TMP / EC2LOG)^gam)),
  data = SDZ_1_19,
  start = start_values,
  control = nls.lm.control(maxiter = 200))

parameters_sdz_1_19 <- summary(sdz_1_19)

#1_99
smx_1_99 <- nlsLM(
 delta_i_x ~ delta_i_max - ((delta_i_max - delta_i_min) * ((CONC_TMP / EC2LOG)^gam) / (((-2 - delta_i_min) / delta_i_max + 2) + (CONC_TMP / EC2LOG)^gam)),
  data = SMX_1_99,
  start = start_values,
  control = nls.lm.control(maxiter = 200))

parameters_smx_1_99 <- summary(smx_1_99)

sdmx_1_99 <- nlsLM(
 delta_i_x ~ delta_i_max - ((delta_i_max - delta_i_min) * ((CONC_TMP / EC2LOG)^gam) / (((-2 - delta_i_min) / delta_i_max + 2) + (CONC_TMP / EC2LOG)^gam)),
  data = SDMX_1_99,
  start = start_values,
  control = nls.lm.control(maxiter = 200))

parameters_sdmx_1_99 <- summary(sdmx_1_99)

sdz_1_99 <- nlsLM(
 delta_i_x ~ delta_i_max - ((delta_i_max - delta_i_min) * ((CONC_TMP / EC2LOG)^gam) / (((-2 - delta_i_min) / delta_i_max + 2) + (CONC_TMP / EC2LOG)^gam)),
  data = SDZ_1_99,
  start = start_values,
  control = nls.lm.control(maxiter = 200))

parameters_sdz_1_99 <- summary(sdz_1_99)

#1_999
smx_1_999 <- nlsLM(
 delta_i_x ~ delta_i_max - ((delta_i_max - delta_i_min) * ((CONC_TMP / EC2LOG)^gam) / (((-2 - delta_i_min) / delta_i_max + 2) + (CONC_TMP / EC2LOG)^gam)),
  data = SMX_1_999,
  start = start_values,
  control = nls.lm.control(maxiter = 200))

parameters_smx_1_999 <- summary(smx_1_999)

sdmx_1_999 <- nlsLM(
 delta_i_x ~ delta_i_max - ((delta_i_max - delta_i_min) * ((CONC_TMP / EC2LOG)^gam) / (((-2 - delta_i_min) / delta_i_max + 2) + (CONC_TMP / EC2LOG)^gam)),
  data = SDMX_1_99,
  start = start_values,
  control = nls.lm.control(maxiter = 200))

parameters_sdmx_1_999 <- summary(sdmx_1_999)

sdz_1_999 <- nlsLM(
 delta_i_x ~ delta_i_max - ((delta_i_max - delta_i_min) * ((CONC_TMP / EC2LOG)^gam) / (((-2 - delta_i_min) / delta_i_max + 2) + (CONC_TMP / EC2LOG)^gam)),
  data = SDZ_1_999,
  start = start_values,
  control = nls.lm.control(maxiter = 200))

parameters_sdz_1_999 <- summary(sdz_1_999)

```

#Log ratio of AUCFU (LR)
```{r}
# Fonction pour calculer l'aire sous une courbe en utilisant la methode des trapezes
calculate_area_trapezoids_LR <- function(x, y) {
  # S'assurer que les donnees sont triees par x
  sorted_indices <- order(x)
  x <- x[sorted_indices]
  y <- y[sorted_indices]
  # Calculer l'aire en utilisant la methode des trapezes
  area_LR <- sum(diff(x) * (head(y, -1) + tail(y, -1)) / 2)
  return(area_LR)
}

# Agreger les donnees par ID, xCMI et TIME, en calculant la moyenne de LOG10_CFU pour chaque groupe
grouped_data_LR <- data_set %>%
  group_by(ID,Idbis, xCMI, TIME, CONC_TMP, ratio) %>%
  summarize(avg_LOG_CFU = mean(OBS_CFU, na.rm = TRUE), .groups = 'drop')

# Calculer l'aire sous chaque courbe pour chaque combinaison de ID et xCMI
areas_LR <- grouped_data_LR %>%
  group_by(ID, xCMI, CONC_TMP, ratio) %>%
  summarize(area_under_curve_LR = calculate_area_trapezoids_LR (TIME, avg_LOG_CFU), .groups = 'drop')

# AUC : histogramme par xCMI
ggplot(areas_LR, aes(x = factor(xCMI), y = area_under_curve_LR, fill = factor(xCMI))) +
  geom_bar(stat = "identity") +
  facet_wrap(~ ID) +
  labs(title = "Aire sous chaque courbe par ID et xCMI", x = "xCMI", y = "Aire sous la courbe") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  scale_fill_discrete(name = "xCMI")
```

```{r}
#Calcul LR
library(dplyr)
library(stringr)

# Definir la fonction calculate_area_trapezoids_LR
calculate_area_trapezoids_LR <- function(x, y) {
  area <- sum(diff(x) * (head(y, -1) + tail(y, -1)) / 2)
  return(area)
}

# Calculer l'AUC pour CONC = 0 (ref)
auc_ref <- grouped_data_LR %>%
  filter(CONC_TMP == 0) %>%
  group_by(ID, Idbis) %>%
  summarize(AUCFU_ref = calculate_area_trapezoids_LR(TIME, avg_LOG_CFU), .groups = 'drop')

# Calculer l'AUC pour CONC ≠ 0 (test)
auc_test <- grouped_data_LR %>%
  filter(CONC_TMP != 0) %>%
  group_by(Idbis, ratio, CONC_TMP,xCMI) %>%
  summarize(AUCFU_test = calculate_area_trapezoids_LR(TIME, avg_LOG_CFU), .groups = 'drop')

# Combiner les deux tables en fonction de l'ID
auc_combined <- auc_test %>%
  left_join(auc_ref, by = "Idbis")

# Gerer les cas ou AUCFU_ref ou AUC_test sont NA
auc_combined <- auc_combined %>%
  filter(!is.na(AUCFU_ref) & !is.na(AUCFU_test))

# Calculer LR
auc_combined <- auc_combined %>%
  mutate(LR = log10(AUCFU_test/AUCFU_ref))

 tableau_LR <- auc_combined %>%
    select(CONC_TMP, LR, Idbis) %>%
    mutate(Idbis = substr(Idbis, 1, nchar(Idbis) - 10))

# Afficher le tableau final des LR
print(tableau_LR)

tableau_LR_pivot <- tableau_LR %>%
  pivot_wider(names_from = CONC_TMP, values_from = LR)

print(tableau_LR_pivot)
```

#Tableau LR
```{r}
# Calculer la moyenne des LR par groupe de CONC et Idbis
tableau_LR_moyenne <- tableau_LR %>%
  group_by(CONC_TMP, Idbis) %>%
  summarize(mean_LR = mean(LR, na.rm = TRUE))

tableau_LR_pivot_moyenne <- tableau_LR_moyenne %>%
  pivot_wider(names_from = CONC_TMP, values_from = mean_LR)

# Extraire la colonne Idbis
Idbis_column <- tableau_LR_pivot_moyenne$Idbis

# Réorganiser les autres colonnes
tableau_LR_pivot_moyenne <- tableau_LR_pivot_moyenne[, -1]
tableau_LR_pivot_moyenne <- tableau_LR_pivot_moyenne[, order(-as.numeric(colnames(tableau_LR_pivot_moyenne)))]

# Recombiner avec la colonne Idbis
tableau_LR_pivot_moyenne <- cbind(Idbis_column, tableau_LR_pivot_moyenne)

print(tableau_LR_pivot_moyenne)


#Exporter tableau LR_pivot
library(writexl)
write_xlsx(tableau_LR_pivot_moyenne, "tableau_LR.xlsx")
```

