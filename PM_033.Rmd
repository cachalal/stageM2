---
title: "PM_033"
author: "Sarah LE COZ"
date: "2024-05-22"
output: pdf_document
---

```{r}
library(tidyverse)
library(shiny)
library(htmlwidgets)
library(lattice)
library(mvtnorm)
library(DoseFinding)
library(readr)
library(stats)
library(modelr)
library(tidyverse)
library(gridExtra)
```

#data_set
```{r}
data_set <- read_csv2("N:/4_PROJETS/2022/EMAD_22TQ_Ratio/StageM2_2024/Analyse_R/data_set.csv",
                      col_types = cols(Idbis = col_character(), 
                                       TIME = col_number(), 
                                       OBS_CFU = col_number(), 
                                       LOG10_CFU = col_number(), 
                                       delta_LOG10 = col_number(), 
                                       CMI = col_number(), 
                                       xCMI = col_number(), 
                                       OUTLIER = col_number(), 
                                       SHAPE = col_number()), 
                      trim_ws = TRUE)

data_set$ID<-as.factor(data_set$ID)

#Enlever les OUTLIER==1
data_set %>% filter(OUTLIER==0)->data_set

#Creer colonne avec concentration en ATB (ùg/mL)
data_set$CONC<-data_set$CMI*data_set$xCMI
```

#Courbes uniques
```{r}
library(paletteer)

#Graphe de chaque KC
ggplot(data_set, aes(x = TIME, y = LOG10_CFU, group = xCMI, color = factor(xCMI))) +
  geom_line() +
  geom_point(shape = 18) +
  scale_color_paletteer_d("ggthemes::gdoc") +
  facet_wrap(~ ID)
```

#AUC
```{r}
# Fonction pour calculer l'aire sous une courbe en utilisant la methode des trapezes
calculate_area_trapezoids <- function(x, y) {
  # S'assurer que les donnees sont triees par x
  sorted_indices <- order(x)
  x <- x[sorted_indices]
  y <- y[sorted_indices]
  # Calculer l'aire en utilisant la methode des trapezes
  area <- sum(diff(x) * (head(y, -1) + tail(y, -1)) / 2)
  return(area)
}

# Agreger les donnees par ID, xCMI et TIME, en calculant la moyenne de LOG10_CFU pour chaque groupe
grouped_data_2 <- data_set %>%
  group_by(ID, xCMI, TIME) %>%
  summarize(avg_LOG10_CFU = mean(LOG10_CFU, na.rm = TRUE), .groups = 'drop')

# Calculer l'aire sous chaque courbe pour chaque combinaison de ID et xCMI
areas <- grouped_data_2 %>%
  group_by(ID, xCMI) %>%
  summarize(area_under_curve = calculate_area_trapezoids(TIME, avg_LOG10_CFU), .groups = 'drop')

# AUC : histogramme par xCMI
ggplot(areas, aes(x = factor(xCMI), y = area_under_curve, fill = factor(xCMI))) +
  geom_bar(stat = "identity") +
  facet_wrap(~ ID) +
  labs(title = "Aire sous chaque courbe par ID et xCMI", x = "xCMI", y = "Aire sous la courbe") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  scale_fill_discrete(name = "xCMI")
```

#Equation 1 : Croissance moyenne de l'inoculum
```{r}
#inoculum moyen obtenu apres exposition à ATB pendant 24h
Ix<-areas$area_under_curve/24

tableau_Ix <- data.frame(ID = areas$ID, xCMI = areas$xCMI, Ix = Ix)

#taille de l'inoculum de depart
# Filtrer les donnees pour obtenir les valeurs à TIME = 0.00 pour chaque combinaison de xCMI et ID
valeurs_inoculum <- data_set %>%
  filter(TIME == 0.00) %>%
  select(ID, xCMI, LOG10_CFU)

IBasal<-valeurs_inoculum$LOG10_CFU
  
#croissance moyenne de l'incoulum sur 24h
delta_i_x<-Ix-IBasal

tableau_delta_i_x<- data.frame(ID = areas$ID, xCMI = areas$xCMI, delta_i_x = delta_i_x)
```

#Equation 2 : Modele sigmoide Emax, modelisation de la croissance moyenne de l'inoculum
```{r}
# Definir le modele nls
essai_model <- nls(delta_i_x ~ delta_i_max - ((delta_i_max - delta_i_min) * ((CONC / EC2LOG)^gam) / (((-2 - delta_i_min) / delta_i_max + 2) + (CONC / EC2LOG)^gam)),
                     data = data_set, #nom du dataset
                     start = list(delta_i_max = max(tableau_delta_i_x$delta_i_x), # valeurs initiales pour aider l'algorithme, prendre les valeurs du tableau publi
                                  delta_i_min = min(tableau_delta_i_x$delta_i_x),
                                  EC2LOG = 1.13,
                                  gam = 2.2) # modifiez l'equation comme dans la publi, avec y = deltaI(x) et x = conc antibio

#obtenir les valeurs des parametres
summary(essai_model)

#obtenir la valeur de R?
rsquare(essai_model,data_set)


#afficher le graphe
new <- data.frame(AUC_CMI=seq(0, 800, by=1))
new$fit <-predict(nls_fit, new)


data_set %>% ggplot()+ geom_point(aes(x = AUC_CMI, y =delta_LOG10)) +   
  geom_line(data=new, aes(x=AUC_CMI, y=fit), color="red")
```

