---
title: "PM_033"
author: "Sarah LE COZ"
date: "2024-05-22"
output: pdf_document
---

```{r}
library(tidyverse)
library(shiny)
library(htmlwidgets)
library(lattice)
library(mvtnorm)
library(DoseFinding)
library(readr)
library(stats)
library(modelr)
library(tidyverse)
library(gridExtra)
```

#data_set
```{r}
data_set <- read_csv2("N:/4_PROJETS/2022/EMAD_22TQ_Ratio/StageM2_2024/Analyse_R/data_set.csv",
                      col_types = cols(Idbis = col_character(), 
                                       TIME = col_number(), 
                                       OBS_CFU = col_number(), 
                                       LOG10_CFU = col_number(), 
                                       delta_LOG10 = col_number(), 
                                       CMI = col_number(), 
                                       xCMI = col_number(), 
                                       OUTLIER = col_number(), 
                                       SHAPE = col_number()), 
                      trim_ws = TRUE)

data_set$ID<-as.factor(data_set$ID)

#Enlever les OUTLIER==1
data_set %>% filter(OUTLIER==0)->data_set

data_set$CONC<-data_set$CMI*data_set$xCMI
```

#Courbes uniques
```{r}
library(paletteer)

#Graphe de chaque KC
ggplot(data_set, aes(x = TIME, y = LOG10_CFU, group = xCMI, color = factor(xCMI))) +
  geom_line() +
  geom_point(shape = 18) +
  scale_color_paletteer_d("ggthemes::gdoc") +
  facet_wrap(~ ID)
```

#AUC
```{r}
# Fonction pour calculer l'aire sous une courbe en utilisant la methode des trapezes
calculate_area_trapezoids <- function(x, y) {
  # S'assurer que les donnees sont triees par x
  sorted_indices <- order(x)
  x <- x[sorted_indices]
  y <- y[sorted_indices]
  # Calculer l'aire en utilisant la methode des trapezes
  area <- sum(diff(x) * (head(y, -1) + tail(y, -1)) / 2)
  return(area)
}

# Agreger les donnees par ID, xCMI et TIME, en calculant la moyenne de LOG10_CFU pour chaque groupe
grouped_data_2 <- data_set %>%
  group_by(ID, xCMI, TIME, CONC_sulf, CONC_TMP, CONC, Idbis) %>%
  summarize(avg_LOG10_CFU = mean(LOG10_CFU, na.rm = TRUE), .groups = 'drop')

# Calculer l'aire sous chaque courbe pour chaque combinaison de ID et xCMI
areas <- grouped_data_2 %>%
  group_by(ID, Idbis, xCMI, CONC_sulf, CONC_TMP, CONC) %>%
  summarize(area_under_curve = calculate_area_trapezoids(TIME, avg_LOG10_CFU), .groups = 'drop')

# AUC : histogramme par xCMI
ggplot(areas, aes(x = factor(xCMI), y = area_under_curve, fill = factor(xCMI))) +
  geom_bar(stat = "identity") +
  facet_wrap(~ ID) +
  labs(title = "Aire sous chaque courbe par ID et xCMI", x = "xCMI", y = "Aire sous la courbe") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  scale_fill_discrete(name = "xCMI")
```

#Equation 1 : Croissance moyenne de l'inoculum
```{r}
#inoculum moyen obtenu apres exposition à ATB pendant 24h (ou 8h pour ID 3, 5 et 33)

Ix <- ifelse(areas$ID %in% c(3, 5, 33), areas$area_under_curve / 8, areas$area_under_curve / 24)

tableau_Ix <- data.frame(ID = areas$ID, Idbis=areas$Idbis, xCMI = areas$xCMI, Ix = Ix)

tableau_Ix <- tableau_Ix %>%
  filter(!ID %in% c(3, 5, 33))

#taille de l'inoculum de depart
# Filtrer les donnees pour obtenir les valeurs à TIME = 0.00 pour chaque combinaison de xCMI et ID
valeurs_inoculum <- data_set %>%
  filter(TIME == 0.00) %>%
  select(ID, xCMI, LOG10_CFU)

IBasal<-valeurs_inoculum$LOG10_CFU
  
#croissance moyenne de l'incoulum sur 24h
delta_i_x<-Ix-IBasal

tableau_delta_i_x<- data.frame(ID = areas$ID, xCMI = areas$xCMI, delta_i_x = delta_i_x)

tableau_delta_i_x <- data.frame(ID = areas$ID,
                                xCMI = areas$xCMI,
                                delta_i_x = delta_i_x,
                                CONC = areas$CONC)

```

#Equation 2 : Modele sigmoide Emax, modelisation de la croissance moyenne de l'inoculum
```{r}
# Definir le modele nls
essai_model <- nls(delta_i_x ~ delta_i_max - ((delta_i_max - delta_i_min) * ((CONC / EC2LOG)^gam) / (((-2 - delta_i_min) / delta_i_max + 2) + (CONC / EC2LOG)^gam)),
                     data = tableau_delta_i_x, # nom du dataset
                     start = list(delta_i_max = max(tableau_delta_i_x$delta_i_x), # valeurs initiales pour aider l'algorithme, prendre les valeurs du tableau publi
                                  delta_i_min = min(tableau_delta_i_x$delta_i_x),
                                  EC2LOG = 1.13,
                                  gam = 2.2))
 # modifiez l'equation comme dans la publi, avec y = deltaI(x) et x = conc antibio

#obtenir les valeurs des parametres
summary(essai_model)

#obtenir la valeur de R?
rsquare(essai_model,data_set)


#afficher le graphe
new <- data.frame(AUC_CMI=seq(0, 800, by=1))
new$fit <-predict(nls_fit, new)


data_set %>% ggplot()+ geom_point(aes(x = AUC_CMI, y =delta_LOG10)) +   
  geom_line(data=new, aes(x=AUC_CMI, y=fit), color="red")
```

#Log ratio of AUCFU (LR)
```{r}
# Fonction pour calculer l'aire sous une courbe en utilisant la methode des trapezes
calculate_area_trapezoids_LR <- function(x, y) {
  # S'assurer que les donnees sont triees par x
  sorted_indices <- order(x)
  x <- x[sorted_indices]
  y <- y[sorted_indices]
  # Calculer l'aire en utilisant la methode des trapezes
  area_LR <- sum(diff(x) * (head(y, -1) + tail(y, -1)) / 2)
  return(area_LR)
}

# Agreger les donnees par ID, xCMI et TIME, en calculant la moyenne de LOG10_CFU pour chaque groupe
grouped_data_LR <- data_set %>%
  group_by(ID,Idbis, xCMI, TIME, CONC_sulf, ratio) %>%
  summarize(avg_LOG_CFU = mean(OBS_CFU, na.rm = TRUE), .groups = 'drop')

# Calculer l'aire sous chaque courbe pour chaque combinaison de ID et xCMI
areas_LR <- grouped_data_LR %>%
  group_by(ID, xCMI, CONC_sulf, ratio) %>%
  summarize(area_under_curve_LR = calculate_area_trapezoids_LR (TIME, avg_LOG_CFU), .groups = 'drop')

# AUC : histogramme par xCMI
ggplot(areas_LR, aes(x = factor(xCMI), y = area_under_curve_LR, fill = factor(xCMI))) +
  geom_bar(stat = "identity") +
  facet_wrap(~ ID) +
  labs(title = "Aire sous chaque courbe par ID et xCMI", x = "xCMI", y = "Aire sous la courbe") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  scale_fill_discrete(name = "xCMI")
```

```{r}
#Calcul LR
library(dplyr)
library(stringr)

# Definir la fonction calculate_area_trapezoids_LR
calculate_area_trapezoids_LR <- function(x, y) {
  area <- sum(diff(x) * (head(y, -1) + tail(y, -1)) / 2)
  return(area)
}

# Calculer l'AUC pour CONC = 0 (ref)
auc_ref <- grouped_data_LR %>%
  filter(CONC_sulf == 0) %>%
  group_by(ID, Idbis) %>%
  summarize(AUCFU_ref = calculate_area_trapezoids_LR(TIME, avg_LOG_CFU), .groups = 'drop')

# Calculer l'AUC pour CONC ≠ 0 (test)
auc_test <- grouped_data_LR %>%
  filter(CONC_sulf != 0) %>%
  group_by(ID, ratio, CONC_sulf,xCMI) %>%
  summarize(AUCFU_test = calculate_area_trapezoids_LR(TIME, avg_LOG_CFU), .groups = 'drop')

# Combiner les deux tables en fonction de l'ID
auc_combined <- auc_test %>%
  left_join(auc_ref, by = "ID")

# Gerer les cas ou AUCFU_ref ou AUC_test sont NA
auc_combined <- auc_combined %>%
  filter(!is.na(AUCFU_ref) & !is.na(AUCFU_test))

# Calculer LR
auc_combined <- auc_combined %>%
  mutate(LR = log10(AUCFU_test/AUCFU_ref))

 tableau_LR <- auc_combined %>%
    select(CONC_sulf, LR, Idbis) %>%
    mutate(Idbis = substr(Idbis, 1, nchar(Idbis) - 10))

# Afficher le tableau final des LR
print(tableau_LR)

tableau_LR_pivot <- tableau_LR %>%
  pivot_wider(names_from = CONC_sulf, values_from = LR)

print(tableau_LR_pivot)
```
#Tableau LR
```{r}
# Calculer la moyenne des LR par groupe de CONC et Idbis
tableau_LR_moyenne <- tableau_LR %>%
  group_by(CONC_sulf, Idbis) %>%
  summarize(mean_LR = mean(LR, na.rm = TRUE))

tableau_LR_pivot_moyenne <- tableau_LR_moyenne %>%
  pivot_wider(names_from = CONC_sulf, values_from = mean_LR)

# Extraire la colonne Idbis
Idbis_column <- tableau_LR_pivot_moyenne$Idbis

# Réorganiser les autres colonnes
tableau_LR_pivot_moyenne <- tableau_LR_pivot_moyenne[, -1]
tableau_LR_pivot_moyenne <- tableau_LR_pivot_moyenne[, order(-as.numeric(colnames(tableau_LR_pivot_moyenne)))]

# Recombiner avec la colonne Idbis
tableau_LR_pivot_moyenne <- cbind(Idbis_column, tableau_LR_pivot_moyenne)

print(tableau_LR_pivot_moyenne)


#Exporter tableau LR_pivot
library(writexl)
write_xlsx(tableau_LR_pivot_moyenne, "LR_033.xlsx")
```

